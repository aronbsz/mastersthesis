%----------------------------------------------------------------------------
\chapter{Introduction}
%----------------------------------------------------------------------------

\section{Context}

Model-based technologies can be used to optimize the process of system design and development, by enabling the automatization of various tasks. Given a formal model of a system under design, the verification and analysis of the system can be automated and model-based code generation becomes possible.

\section{Problem Statement}

%biztonsági protokoll etc
The reactive components of a system, such as communication and security protocols, are typically modeled using state-based formalisms. The manual design of these components can often be a difficult task, since these protocols are more easily defined by their behavior. Specifically, describing the behavior of such a system by example runs proves to be an easier task then modeling them outright. A communication protocol for instance, can be defined by the union of every runs behavior from the viewpoints of every participant of the communication. To the best of my knowledge, there is is no current software, that enables the modeling of a system, or a system component by the description of its example runs which is capable of performing the desired analysis on the output.

\section{Objective}

The objective of my work was to design a framework capable of supporting system design by modeling a system (component) based on example-runs describing its behavior. Behavioral state-based modeling is the strength of automaton learning algorithms, specifically, active automaton learning algorithms excel at monitoring system behavior, which is why they are the core of the framework that I created.

\section{Contribution}

%TTT, DHC hivatkozva
To realize my goal, I have created an automaton learning framework capable of handling arbitrary formalisms in a modular, easily extensible and integrable way. In the framework, I implemented two active automaton learning algorithms, the Direct Hypothesis Construction\cite{10.1007/978-3-642-34781-8_19} and the TTT\cite{10.1007/978-3-319-11164-3_26} algorithms, both capable of infering a system using behavioral information.

\section{Related work}

%Össze kell gyűjteni a kapcsolódó munkákat. LearnLib tanul, gamma, theta felhasznál, de tanulni nem tud. Riválisok: automatatanuló keretrendszer, szoftver vagy protokollt lehet ilyen módon tervezni, algok összehasonlítása

%szoftver neve, hivatkozás, mit csinál (röviden), viszont mi az amit nem tud ehhez képest. pl. gamma lehetővé teszi szoftvetkomponensek automata alapú fejlesztését, nem tud automata tanulást

There are many automaton learning tools in the literature, including
\emph{LearnLib}\cite{10.1007/978-3-319-21690-4_32} that provides a Java framework for active and passive automaton learning, with the versatile AutomataLib framework acting as a backbone of it, but has no native support for software-component development. The \emph{libalf} framework also provides learning techniques for finite automata implemented in \emph{C++}. \emph{Tomte}\cite{aarts2012automata} is a framework utilizing LearnLib for counterexample driven abstraction refinement of real software components modeled in a restricted class of finite automata. 

Modular and extendable frameworks include the \emph{Gamma Statechart Composition framework}\cite{DBLP:conf/icse/MolnarGVMV18} that provides automata-based development of software components, as well as the \emph{Theta framework}\cite{theta-fmcad2017} which enables the evaluation of abstraction refinement-based algorithms. Both of them are developed by the department but neither has support for automaton learning.

\section{Added value}

%Hogyan segíti elő ezeket %TTT bonyolult, csak LearnLibben
The presented framework, while capable of system design using example runs, also enables the modular implementation of active automaton learning algorithms and the formalisms they might depend on. Additionally, it makes the comparison of different learning algorithms possible in the same environment (and such, with the same overhead), and allows the discretionary use of the automaton learning algorithms implemented therein.

\section{Outline}

The paper is organized as follows. Chapter 2 provides an outline of the necessary theoretical background. Chapter 3 gives insight into the contribution presented in this thesis. Chapter 4 evaluates the correctness of the presented framework and the algorithms implemented within -- both theoretically and experimentally. Chapter 5 concludes the thesis and presents future work goals.
